#!/usr/bin/env perl
use v5.16;
use utf8;
use FindBin;
use lib "$FindBin::Bin/lib";

use Fe;

use List::Util qw(shuffle);
use URI;
use XML::XPath;
use XML::Feed;
use Encode qw(encode_utf8 decode_utf8);

use Data::Dumper qw(Dumper);

sub feed_urls_in_opml {
    my @urls;
    my ($opml_file) = @_;
    my $xp = XML::XPath->new($opml_file);
    for my $node ($xp->find("//outline")->get_nodelist) {
        my @attr = $node->getAttributes;
        for my $attr (@attr) {
            if ((my $name = $attr->getLocalName) =~ /^xmlurl$/i) {
                if (my $data = $attr->getData) {
                    push @urls, $data
                }
            }
        }
    }
    return @urls;
}


my $fe = Fe->new;
my $domain = $fe->domain("feeds");

sub process_feed {
    my ($feed_url) = @_;

    my $feed = XML::Feed->parse( URI->new($feed_url) ) or do {
        print STDERR "Skip: $feed_url Reason: " . XML::Feed->errstr . "\n";
        return;
    };

    print STDERR "Process $feed_url\n";

    for my $entry ($feed->entries) {
        my $title = $entry->title;
        my $body = $entry->content->body or do {
            print STDERR "Skip " . $entry->link . " Reason: No body.\n";
            next;
        };

        utf8::decode($body)  unless utf8::is_utf8($body);
        utf8::decode($title) unless utf8::is_utf8($title);

        my $doc = $domain->new_doc(
            feed_entry => {
                url     => $entry->link,
                feed    => $feed_url,
                content => $body,
                title   => $title,
            }
        );

        $doc->save(on_unique => sub {});
    }
}

if (@ARGV == 0) {
    die "Requiers an OPML path or an Feed URL";
}

my @urls;
if (-f $ARGV[0]) {
    @urls = shuffle feed_urls_in_opml($ARGV[0]);
}
else {
    push @urls, @ARGV;
}

for my $feed_url (@urls) {
    eval {
        process_feed($feed_url);
        1;
    } or do {
        print STDERR "Error: $@\n";
    }
}

